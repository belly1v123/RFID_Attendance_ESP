// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package my_queries

import (
	"context"
	"database/sql"

	"github.com/ronishg27/rfid_attendance/internal/models/tenant"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newScanLog(db *gorm.DB, opts ...gen.DOOption) scanLog {
	_scanLog := scanLog{}

	_scanLog.scanLogDo.UseDB(db, opts...)
	_scanLog.scanLogDo.UseModel(&tenant.ScanLog{})

	tableName := _scanLog.scanLogDo.TableName()
	_scanLog.ALL = field.NewAsterisk(tableName)
	_scanLog.ID = field.NewString(tableName, "id")
	_scanLog.RFIDUID = field.NewString(tableName, "rf_id_uid")
	_scanLog.DeviceID = field.NewString(tableName, "device_id")
	_scanLog.ScannedAt = field.NewTime(tableName, "scanned_at")
	_scanLog.Recognized = field.NewBool(tableName, "recognized")

	_scanLog.fillFieldMap()

	return _scanLog
}

type scanLog struct {
	scanLogDo

	ALL        field.Asterisk
	ID         field.String
	RFIDUID    field.String
	DeviceID   field.String
	ScannedAt  field.Time
	Recognized field.Bool

	fieldMap map[string]field.Expr
}

func (s scanLog) Table(newTableName string) *scanLog {
	s.scanLogDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s scanLog) As(alias string) *scanLog {
	s.scanLogDo.DO = *(s.scanLogDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *scanLog) updateTableName(table string) *scanLog {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewString(table, "id")
	s.RFIDUID = field.NewString(table, "rf_id_uid")
	s.DeviceID = field.NewString(table, "device_id")
	s.ScannedAt = field.NewTime(table, "scanned_at")
	s.Recognized = field.NewBool(table, "recognized")

	s.fillFieldMap()

	return s
}

func (s *scanLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *scanLog) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 5)
	s.fieldMap["id"] = s.ID
	s.fieldMap["rf_id_uid"] = s.RFIDUID
	s.fieldMap["device_id"] = s.DeviceID
	s.fieldMap["scanned_at"] = s.ScannedAt
	s.fieldMap["recognized"] = s.Recognized
}

func (s scanLog) clone(db *gorm.DB) scanLog {
	s.scanLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s scanLog) replaceDB(db *gorm.DB) scanLog {
	s.scanLogDo.ReplaceDB(db)
	return s
}

type scanLogDo struct{ gen.DO }

type IScanLogDo interface {
	gen.SubQuery
	Debug() IScanLogDo
	WithContext(ctx context.Context) IScanLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IScanLogDo
	WriteDB() IScanLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IScanLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IScanLogDo
	Not(conds ...gen.Condition) IScanLogDo
	Or(conds ...gen.Condition) IScanLogDo
	Select(conds ...field.Expr) IScanLogDo
	Where(conds ...gen.Condition) IScanLogDo
	Order(conds ...field.Expr) IScanLogDo
	Distinct(cols ...field.Expr) IScanLogDo
	Omit(cols ...field.Expr) IScanLogDo
	Join(table schema.Tabler, on ...field.Expr) IScanLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IScanLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IScanLogDo
	Group(cols ...field.Expr) IScanLogDo
	Having(conds ...gen.Condition) IScanLogDo
	Limit(limit int) IScanLogDo
	Offset(offset int) IScanLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IScanLogDo
	Unscoped() IScanLogDo
	Create(values ...*tenant.ScanLog) error
	CreateInBatches(values []*tenant.ScanLog, batchSize int) error
	Save(values ...*tenant.ScanLog) error
	First() (*tenant.ScanLog, error)
	Take() (*tenant.ScanLog, error)
	Last() (*tenant.ScanLog, error)
	Find() ([]*tenant.ScanLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*tenant.ScanLog, err error)
	FindInBatches(result *[]*tenant.ScanLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*tenant.ScanLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IScanLogDo
	Assign(attrs ...field.AssignExpr) IScanLogDo
	Joins(fields ...field.RelationField) IScanLogDo
	Preload(fields ...field.RelationField) IScanLogDo
	FirstOrInit() (*tenant.ScanLog, error)
	FirstOrCreate() (*tenant.ScanLog, error)
	FindByPage(offset int, limit int) (result []*tenant.ScanLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IScanLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s scanLogDo) Debug() IScanLogDo {
	return s.withDO(s.DO.Debug())
}

func (s scanLogDo) WithContext(ctx context.Context) IScanLogDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s scanLogDo) ReadDB() IScanLogDo {
	return s.Clauses(dbresolver.Read)
}

func (s scanLogDo) WriteDB() IScanLogDo {
	return s.Clauses(dbresolver.Write)
}

func (s scanLogDo) Session(config *gorm.Session) IScanLogDo {
	return s.withDO(s.DO.Session(config))
}

func (s scanLogDo) Clauses(conds ...clause.Expression) IScanLogDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s scanLogDo) Returning(value interface{}, columns ...string) IScanLogDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s scanLogDo) Not(conds ...gen.Condition) IScanLogDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s scanLogDo) Or(conds ...gen.Condition) IScanLogDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s scanLogDo) Select(conds ...field.Expr) IScanLogDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s scanLogDo) Where(conds ...gen.Condition) IScanLogDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s scanLogDo) Order(conds ...field.Expr) IScanLogDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s scanLogDo) Distinct(cols ...field.Expr) IScanLogDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s scanLogDo) Omit(cols ...field.Expr) IScanLogDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s scanLogDo) Join(table schema.Tabler, on ...field.Expr) IScanLogDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s scanLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IScanLogDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s scanLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IScanLogDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s scanLogDo) Group(cols ...field.Expr) IScanLogDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s scanLogDo) Having(conds ...gen.Condition) IScanLogDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s scanLogDo) Limit(limit int) IScanLogDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s scanLogDo) Offset(offset int) IScanLogDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s scanLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IScanLogDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s scanLogDo) Unscoped() IScanLogDo {
	return s.withDO(s.DO.Unscoped())
}

func (s scanLogDo) Create(values ...*tenant.ScanLog) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s scanLogDo) CreateInBatches(values []*tenant.ScanLog, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s scanLogDo) Save(values ...*tenant.ScanLog) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s scanLogDo) First() (*tenant.ScanLog, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*tenant.ScanLog), nil
	}
}

func (s scanLogDo) Take() (*tenant.ScanLog, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*tenant.ScanLog), nil
	}
}

func (s scanLogDo) Last() (*tenant.ScanLog, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*tenant.ScanLog), nil
	}
}

func (s scanLogDo) Find() ([]*tenant.ScanLog, error) {
	result, err := s.DO.Find()
	return result.([]*tenant.ScanLog), err
}

func (s scanLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*tenant.ScanLog, err error) {
	buf := make([]*tenant.ScanLog, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s scanLogDo) FindInBatches(result *[]*tenant.ScanLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s scanLogDo) Attrs(attrs ...field.AssignExpr) IScanLogDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s scanLogDo) Assign(attrs ...field.AssignExpr) IScanLogDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s scanLogDo) Joins(fields ...field.RelationField) IScanLogDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s scanLogDo) Preload(fields ...field.RelationField) IScanLogDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s scanLogDo) FirstOrInit() (*tenant.ScanLog, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*tenant.ScanLog), nil
	}
}

func (s scanLogDo) FirstOrCreate() (*tenant.ScanLog, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*tenant.ScanLog), nil
	}
}

func (s scanLogDo) FindByPage(offset int, limit int) (result []*tenant.ScanLog, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s scanLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s scanLogDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s scanLogDo) Delete(models ...*tenant.ScanLog) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *scanLogDo) withDO(do gen.Dao) *scanLogDo {
	s.DO = *do.(*gen.DO)
	return s
}
